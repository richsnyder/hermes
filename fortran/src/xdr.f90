! DISTRIBUTION STATEMENT A. Approved for public release; distribution is
! unlimited.  Granted clearance per 88ABW-2016-0371.
!
! This file is declared a work of the U.S. Government and is not subject to
! copyright protection in the United States.

MODULE XDR

  USE, INTRINSIC :: ISO_C_BINDING
  IMPLICIT NONE
  PRIVATE

  TYPE, PUBLIC :: XDR_T
      CHARACTER(KIND = C_CHAR, LEN = :), POINTER, PRIVATE :: BUFFER
      INTEGER(KIND = C_SIZE_T), PRIVATE :: MAX_STRING_SIZE
      INTEGER(KIND = C_SIZE_T), PRIVATE :: BUFFER_SIZE
      INTEGER(KIND = C_SIZE_T), PRIVATE :: OFFSET
      LOGICAL, PRIVATE :: OWNS_BUFFER
    CONTAINS
      GENERIC, PUBLIC :: CREATE => &
          XDR_CREATE_DATA, XDR_CREATE_DATA_SIZE_T, &
          XDR_CREATE_SIZE, XDR_CREATE_SIZE_SIZE_T
      PROCEDURE, PRIVATE :: XDR_CREATE_DATA
      PROCEDURE, PRIVATE :: XDR_CREATE_DATA_SIZE_T
      PROCEDURE, PRIVATE :: XDR_CREATE_SIZE
      PROCEDURE, PRIVATE :: XDR_CREATE_SIZE_SIZE_T

      PROCEDURE, PUBLIC :: READ_FILE => XDR_READ_FILE
      PROCEDURE, PUBLIC :: WRITE_FILE => XDR_WRITE_FILE

      PROCEDURE, PUBLIC :: DESTROY => XDR_DESTROY

      PROCEDURE, PUBLIC :: GETPOS => XDR_GETPOS
      PROCEDURE, PUBLIC :: SETPOS => XDR_SETPOS
      PROCEDURE, PUBLIC :: GETSIZE => XDR_GETSIZE
      PROCEDURE, PUBLIC :: GETDATA => XDR_GETDATA

      PROCEDURE, PUBLIC :: LARGEST_STRING_ALLOCATION => XDR_MAX_STRING_SIZE

      GENERIC, PUBLIC :: GET => &
          XDR_GET_VOID, XDR_GET_LOGICAL, &
          XDR_GET_INT8, XDR_GET_INT16, &
          XDR_GET_INT32, XDR_GET_INT64, &
          XDR_GET_FLOAT, XDR_GET_DOUBLE, &
          XDR_GET_BYTES, XDR_GET_STRING
      PROCEDURE, PRIVATE :: XDR_GET_VOID
      PROCEDURE, PRIVATE :: XDR_GET_LOGICAL
      PROCEDURE, PRIVATE :: XDR_GET_INT8
      PROCEDURE, PRIVATE :: XDR_GET_INT16
      PROCEDURE, PRIVATE :: XDR_GET_INT32
      PROCEDURE, PRIVATE :: XDR_GET_INT64
      PROCEDURE, PRIVATE :: XDR_GET_FLOAT
      PROCEDURE, PRIVATE :: XDR_GET_DOUBLE
      PROCEDURE, PRIVATE :: XDR_GET_BYTES
      PROCEDURE, PRIVATE :: XDR_GET_STRING

      PROCEDURE, PUBLIC :: GET_CHARACTER => XDR_GET_CHARACTER

      GENERIC, PUBLIC :: GET_UNSIGNED => &
          XDR_GET_UINT8, &
          XDR_GET_UINT16, &
          XDR_GET_UINT32
      PROCEDURE, PRIVATE :: XDR_GET_UINT8
      PROCEDURE, PRIVATE :: XDR_GET_UINT16
      PROCEDURE, PRIVATE :: XDR_GET_UINT32

      GENERIC, PUBLIC :: GET_VECTOR => &
          XDR_GET_LOGICAL_VECTOR, &
          XDR_GET_INT8_VECTOR, XDR_GET_INT16_VECTOR, &
          XDR_GET_INT32_VECTOR, XDR_GET_INT64_VECTOR, &
          XDR_GET_FLOAT_VECTOR, XDR_GET_DOUBLE_VECTOR, &
          XDR_GET_BYTES_VECTOR, XDR_GET_STRING_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_LOGICAL_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT64_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_FLOAT_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_DOUBLE_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_BYTES_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_STRING_VECTOR

      PROCEDURE, PUBLIC :: GET_CHARACTER_VECTOR => XDR_GET_CHARACTER_VECTOR

      GENERIC, PUBLIC :: GET_UNSIGNED_VECTOR => &
          XDR_GET_UINT8_VECTOR, &
          XDR_GET_UINT16_VECTOR, &
          XDR_GET_UINT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_UINT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_UINT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_UINT32_VECTOR

      GENERIC, PUBLIC :: GET_ARRAY => &
          XDR_GET_LOGICAL_ARRAY, &
          XDR_GET_INT8_ARRAY, XDR_GET_INT16_ARRAY, &
          XDR_GET_INT32_ARRAY, XDR_GET_INT64_ARRAY, &
          XDR_GET_FLOAT_ARRAY, XDR_GET_DOUBLE_ARRAY, &
          XDR_GET_BYTES_ARRAY, XDR_GET_STRING_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_LOGICAL_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT64_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_FLOAT_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_DOUBLE_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_BYTES_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_STRING_ARRAY

      PROCEDURE, PUBLIC :: GET_CHARACTER_ARRAY => XDR_GET_CHARACTER_ARRAY

      GENERIC, PUBLIC :: GET_UNSIGNED_ARRAY => &
          XDR_GET_UINT8_ARRAY, &
          XDR_GET_UINT16_ARRAY, &
          XDR_GET_UINT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_UINT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_UINT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_UINT32_ARRAY

      GENERIC, PUBLIC :: PUT => &
          XDR_PUT_VOID, XDR_PUT_LOGICAL, &
          XDR_PUT_INT8, XDR_PUT_INT16, &
          XDR_PUT_INT32, XDR_PUT_INT64, &
          XDR_PUT_FLOAT, XDR_PUT_DOUBLE, &
          XDR_PUT_BYTES, XDR_PUT_STRING
      PROCEDURE, PRIVATE :: XDR_PUT_VOID
      PROCEDURE, PRIVATE :: XDR_PUT_LOGICAL
      PROCEDURE, PRIVATE :: XDR_PUT_INT8
      PROCEDURE, PRIVATE :: XDR_PUT_INT16
      PROCEDURE, PRIVATE :: XDR_PUT_INT32
      PROCEDURE, PRIVATE :: XDR_PUT_INT64
      PROCEDURE, PRIVATE :: XDR_PUT_FLOAT
      PROCEDURE, PRIVATE :: XDR_PUT_DOUBLE
      PROCEDURE, PRIVATE :: XDR_PUT_BYTES
      PROCEDURE, PRIVATE :: XDR_PUT_STRING

      PROCEDURE, PUBLIC :: PUT_CHARACTER => XDR_PUT_CHARACTER

      GENERIC, PUBLIC :: PUT_UNSIGNED => &
          XDR_PUT_UINT8, &
          XDR_PUT_UINT16, &
          XDR_PUT_UINT32
      PROCEDURE, PRIVATE :: XDR_PUT_UINT8
      PROCEDURE, PRIVATE :: XDR_PUT_UINT16
      PROCEDURE, PRIVATE :: XDR_PUT_UINT32

      GENERIC, PUBLIC :: PUT_VECTOR => &
          XDR_PUT_LOGICAL_VECTOR, &
          XDR_PUT_INT8_VECTOR, XDR_PUT_INT16_VECTOR, &
          XDR_PUT_INT32_VECTOR, XDR_PUT_INT64_VECTOR, &
          XDR_PUT_FLOAT_VECTOR, XDR_PUT_DOUBLE_VECTOR, &
          XDR_PUT_BYTES_VECTOR, XDR_PUT_STRING_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_LOGICAL_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT64_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_FLOAT_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_DOUBLE_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_BYTES_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_STRING_VECTOR

      PROCEDURE, PUBLIC :: PUT_CHARACTER_VECTOR => XDR_PUT_CHARACTER_VECTOR

      GENERIC, PUBLIC :: PUT_UNSIGNED_VECTOR => &
          XDR_PUT_UINT8_VECTOR, &
          XDR_PUT_UINT16_VECTOR, &
          XDR_PUT_UINT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_UINT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_UINT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_UINT32_VECTOR

      GENERIC, PUBLIC :: PUT_ARRAY => &
          XDR_PUT_LOGICAL_ARRAY, &
          XDR_PUT_INT8_ARRAY, XDR_PUT_INT16_ARRAY, &
          XDR_PUT_INT32_ARRAY, XDR_PUT_INT64_ARRAY, &
          XDR_PUT_FLOAT_ARRAY, XDR_PUT_DOUBLE_ARRAY, &
          XDR_PUT_BYTES_ARRAY, XDR_PUT_STRING_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_LOGICAL_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT64_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_FLOAT_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_DOUBLE_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_BYTES_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_STRING_ARRAY

      PROCEDURE, PUBLIC :: PUT_CHARACTER_ARRAY => XDR_PUT_CHARACTER_ARRAY

      GENERIC, PUBLIC :: PUT_UNSIGNED_ARRAY => &
          XDR_PUT_UINT8_ARRAY, &
          XDR_PUT_UINT16_ARRAY, &
          XDR_PUT_UINT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_UINT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_UINT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_UINT32_ARRAY

      PROCEDURE, PUBLIC :: ALLOCATE_STRING => XDR_ALLOC_STRING

      GENERIC, PUBLIC :: ALLOCATE_ARRAY => &
          XDR_ALLOC_LOGICAL_ARRAY, &
          XDR_ALLOC_INT8_ARRAY, XDR_ALLOC_INT16_ARRAY, &
          XDR_ALLOC_INT32_ARRAY, XDR_ALLOC_INT64_ARRAY, &
          XDR_ALLOC_FLOAT_ARRAY, XDR_ALLOC_DOUBLE_ARRAY, &
          XDR_ALLOC_BYTES_ARRAY, XDR_ALLOC_STRING_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_LOGICAL_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_INT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_INT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_INT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_INT64_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_FLOAT_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_DOUBLE_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_BYTES_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_STRING_ARRAY

      PROCEDURE, PUBLIC :: ALLOCATE_CHARACTER_ARRAY => XDR_ALLOC_CHARACTER_ARRAY

      GENERIC, PUBLIC :: ALLOCATE_UNSIGNED_ARRAY => &
          XDR_ALLOC_UINT8_ARRAY, &
          XDR_ALLOC_UINT16_ARRAY, &
          XDR_ALLOC_UINT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_UINT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_UINT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_ALLOC_UINT32_ARRAY
  END TYPE

  CHARACTER(KIND = C_CHAR, LEN = 3), PARAMETER :: PADDING = REPEAT(C_NULL_CHAR, 3)

  INTERFACE

    FUNCTION FILE_SIZE(FILENAME) RESULT(NBYTES) BIND(C)
      USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_CHAR, C_LONG
      IMPLICIT NONE
      CHARACTER(KIND = C_CHAR), DIMENSION(*), INTENT(IN) :: FILENAME
      INTEGER(KIND = C_LONG) :: NBYTES
    END FUNCTION

    FUNCTION DOWNCAST_UINT32_T(X) RESULT(Y) BIND(C)
      USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT32_T, C_INT64_T
      IMPLICIT NONE
      INTEGER(KIND = C_INT64_T), VALUE, INTENT(IN) :: X
      INTEGER(KIND = C_INT32_T) :: Y
    END FUNCTION

    FUNCTION UPCAST_UINT32_T(X) RESULT(Y) BIND(C)
      USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT32_T, C_INT64_T
      IMPLICIT NONE
      INTEGER(KIND = C_INT32_T), VALUE, INTENT(IN) :: X
      INTEGER(KIND = C_INT64_T) :: Y
    END FUNCTION

  END INTERFACE

CONTAINS

  PURE FUNCTION BSWAP_INT32_T(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT32_T
    IMPLICIT NONE
    INTEGER(KIND = C_INT32_T), INTENT(IN) :: X
    INTEGER(KIND = C_INT32_T) :: Y

    CHARACTER(LEN = 4) :: BYTES_COPY
    CHARACTER(LEN = 4) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(4:4)
    BYTES_SWAP(2:2) = BYTES_COPY(3:3)
    BYTES_SWAP(3:3) = BYTES_COPY(2:2)
    BYTES_SWAP(4:4) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  PURE FUNCTION BSWAP_INT64_T(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT64_T
    IMPLICIT NONE
    INTEGER(KIND = C_INT64_T), INTENT(IN) :: X
    INTEGER(KIND = C_INT64_T) :: Y

    CHARACTER(LEN = 8) :: BYTES_COPY
    CHARACTER(LEN = 8) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(8:8)
    BYTES_SWAP(2:2) = BYTES_COPY(7:7)
    BYTES_SWAP(3:3) = BYTES_COPY(6:6)
    BYTES_SWAP(4:4) = BYTES_COPY(5:5)
    BYTES_SWAP(5:5) = BYTES_COPY(4:4)
    BYTES_SWAP(6:6) = BYTES_COPY(3:3)
    BYTES_SWAP(7:7) = BYTES_COPY(2:2)
    BYTES_SWAP(8:8) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  PURE FUNCTION BSWAP_FLOAT(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_FLOAT
    IMPLICIT NONE
    REAL(KIND = C_FLOAT), INTENT(IN) :: X
    REAL(KIND = C_FLOAT) :: Y

    CHARACTER(LEN = 4) :: BYTES_COPY
    CHARACTER(LEN = 4) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(4:4)
    BYTES_SWAP(2:2) = BYTES_COPY(3:3)
    BYTES_SWAP(3:3) = BYTES_COPY(2:2)
    BYTES_SWAP(4:4) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  PURE FUNCTION BSWAP_DOUBLE(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT64_T
    IMPLICIT NONE
    REAL(KIND = C_DOUBLE), INTENT(IN) :: X
    REAL(KIND = C_DOUBLE) :: Y

    CHARACTER(LEN = 8) :: BYTES_COPY
    CHARACTER(LEN = 8) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(8:8)
    BYTES_SWAP(2:2) = BYTES_COPY(7:7)
    BYTES_SWAP(3:3) = BYTES_COPY(6:6)
    BYTES_SWAP(4:4) = BYTES_COPY(5:5)
    BYTES_SWAP(5:5) = BYTES_COPY(4:4)
    BYTES_SWAP(6:6) = BYTES_COPY(3:3)
    BYTES_SWAP(7:7) = BYTES_COPY(2:2)
    BYTES_SWAP(8:8) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  SUBROUTINE XDR_ALLOCATE_STRINGS(STRING_ARRAY, ARRAY_SIZE, STRING_LENGTH)
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: ARRAY_SIZE
    INTEGER, INTENT(IN) :: STRING_LENGTH
    CHARACTER(KIND = C_CHAR, LEN = STRING_LENGTH), DIMENSION(:), ALLOCATABLE :: STRING_ARRAY

    ALLOCATE(CHARACTER(LEN = STRING_LENGTH) :: STRING_ARRAY(ARRAY_SIZE))
  END SUBROUTINE

  FUNCTION XDR_BLOCK_SIZE(N) RESULT(NBYTES)
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: N
    INTEGER(KIND = C_SIZE_T) :: NBYTES

    NBYTES = IAND(N + 3_C_SIZE_T, NOT(3_C_SIZE_T))
  END FUNCTION

  SUBROUTINE XDR_CREATE_DATA(SELF, BUFFER, NBYTES)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER, INTENT(IN) :: BUFFER
    INTEGER, INTENT(IN) :: NBYTES

    CALL XDR_CREATE_DATA_SIZE_T(SELF, BUFFER, INT(NBYTES, KIND = C_SIZE_T))
  END SUBROUTINE

  SUBROUTINE XDR_CREATE_DATA_SIZE_T(SELF, BUFFER, NBYTES)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER, INTENT(IN) :: BUFFER
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: NBYTES

    SELF%OFFSET = 1
    SELF%BUFFER_SIZE = NBYTES
    SELF%BUFFER => BUFFER
    SELF%OWNS_BUFFER = .FALSE.
    SELF%MAX_STRING_SIZE = 1024
  END SUBROUTINE

  SUBROUTINE XDR_CREATE_SIZE(SELF, NBYTES)
    CLASS(XDR_T) :: SELF
    INTEGER, INTENT(IN) :: NBYTES

    CALL XDR_CREATE_SIZE_SIZE_T(SELF, INT(NBYTES, KIND = C_SIZE_T))
  END SUBROUTINE

  SUBROUTINE XDR_CREATE_SIZE_SIZE_T(SELF, NBYTES)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: NBYTES

    SELF%OFFSET = 1
    SELF%BUFFER_SIZE = NBYTES
    ALLOCATE(CHARACTER(KIND = C_CHAR, LEN = NBYTES) :: SELF%BUFFER)
    SELF%OWNS_BUFFER = .TRUE.
    SELF%MAX_STRING_SIZE = 1024
  END SUBROUTINE

  SUBROUTINE XDR_READ_FILE(SELF, FILENAME)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: FILENAME

    INTEGER :: LENGTH

    SELF%OFFSET = 1
    LENGTH = LEN_TRIM(FILENAME)
    IF (FILENAME(LENGTH:LENGTH) == C_NULL_CHAR) THEN
      SELF%BUFFER_SIZE = FILE_SIZE(TRIM(FILENAME))
      OPEN(UNIT = 21, FILE = FILENAME(1:LENGTH-1), FORM = 'UNFORMATTED', ACCESS = 'STREAM')
    ELSE
      SELF%BUFFER_SIZE = FILE_SIZE(TRIM(FILENAME) // C_NULL_CHAR)
      OPEN(UNIT = 21, FILE = FILENAME, FORM = 'UNFORMATTED', ACCESS = 'STREAM')
    END IF
    ALLOCATE(CHARACTER(KIND = C_CHAR, LEN = SELF%BUFFER_SIZE) :: SELF%BUFFER)
    READ(21) SELF%BUFFER
    CLOSE(UNIT = 21)
    SELF%OWNS_BUFFER = .TRUE.
    SELF%MAX_STRING_SIZE = 1024
  END SUBROUTINE

  SUBROUTINE XDR_WRITE_FILE(SELF, FILENAME)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: FILENAME

    OPEN(UNIT = 21, FILE = FILENAME, FORM = 'UNFORMATTED', ACCESS = 'STREAM')
    WRITE(21) SELF%BUFFER
    CLOSE(UNIT = 21)
  END SUBROUTINE

  SUBROUTINE XDR_DESTROY(SELF)
    CLASS(XDR_T) :: SELF

    SELF%OFFSET = 0
    SELF%BUFFER_SIZE = 0
    IF (SELF%OWNS_BUFFER) THEN
      DEALLOCATE(SELF%BUFFER)
    ELSE
      NULLIFY(SELF%BUFFER)
    END IF
    SELF%OWNS_BUFFER = .FALSE.
  END SUBROUTINE

  FUNCTION XDR_GETPOS(SELF) RESULT(POS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_SIZE_T) :: POS

    POS = SELF%OFFSET
  END FUNCTION

  FUNCTION XDR_SETPOS(SELF, POS) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: POS
    LOGICAL :: SUCCESS

    IF (POS <= (SELF%BUFFER_SIZE + 1) .AND. MOD(POS, 4) == 1) THEN
      SELF%OFFSET = POS
      SUCCESS = .TRUE.
    ELSE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GETSIZE(SELF) RESULT(NBYTES)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_SIZE_T) :: NBYTES

    NBYTES = SELF%BUFFER_SIZE
  END FUNCTION

  SUBROUTINE XDR_GETDATA(SELF, BUFFER)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER, INTENT(OUT) :: BUFFER

    BUFFER => SELF%BUFFER
  END SUBROUTINE

  SUBROUTINE XDR_MAX_STRING_SIZE(SELF, NBYTES)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: NBYTES

    SELF%MAX_STRING_SIZE = NBYTES
  END SUBROUTINE

  FUNCTION XDR_GET_VOID(SELF) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL :: SUCCESS

    SUCCESS = .TRUE.
  END FUNCTION

  FUNCTION XDR_GET_LOGICAL(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    IF (X == 0) THEN
      VAL = .FALSE.
    ELSE IF (X == 1) THEN
      VAL = .TRUE.
    ELSE
      SUCCESS = .FALSE.
      SELF%OFFSET = SELF%OFFSET - C_SIZEOF(X)
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    VAL = INT(X, KIND = C_INT8_T)
  END FUNCTION

  FUNCTION XDR_GET_INT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    VAL = INT(X, KIND = C_INT16_T)
  END FUNCTION

  FUNCTION XDR_GET_INT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_INT32_T(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT64(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_INT64_T(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_FLOAT(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_FLOAT(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_DOUBLE(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_DOUBLE(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_BYTES(SELF, STR, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(OUT) :: STR
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: LENGTH

    SUCCESS = XDR_GET_INT32(SELF, LENGTH)
    SIZE = INT(LENGTH, KIND = C_SIZE_T)
    E = SELF%OFFSET + SIZE - 1
    IF (SUCCESS .AND. E <= SELF%BUFFER_SIZE) THEN
      E = SELF%OFFSET + MIN(SIZE, LEN(STR)) - 1
      STR = SELF%BUFFER(SELF%OFFSET:E)
      SELF%OFFSET = SELF%OFFSET + XDR_BLOCK_SIZE(INT(SIZE, KIND = C_SIZE_T))
    END IF
  END FUNCTION

  FUNCTION XDR_GET_STRING(SELF, STR) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(OUT) :: STR
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: SIZE

    SUCCESS = XDR_GET_BYTES(SELF, STR, SIZE)
  END FUNCTION

  FUNCTION XDR_GET_CHARACTER(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    VAL = CHAR(X)
  END FUNCTION

  FUNCTION XDR_GET_UINT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT64_T) :: X

    SUCCESS = XDR_GET_UINT32(SELF, X)
    VAL = INT(X, KIND = C_INT16_T)
  END FUNCTION

  FUNCTION XDR_GET_UINT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT64_T) :: X

    SUCCESS = XDR_GET_UINT32(SELF, X)
    VAL = INT(X, KIND = C_INT32_T)
  END FUNCTION

  FUNCTION XDR_GET_UINT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: X

    E = SELF%OFFSET + C_SIZEOF(X) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      X = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), X)
      VAL = UPCAST_UINT32_T(BSWAP_INT32_T(X))
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_LOGICAL_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        X = BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            X))
        IF (X == 1) THEN
          VALUES(N) = .TRUE.
        ELSE
          VALUES(N) = .FALSE.
        END IF
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT8_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = INT(BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            X)), KIND = C_INT8_T)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT16_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = INT(BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            X)), KIND = C_INT16_T)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT32_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            VALUES(N)))
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT64_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = BSWAP_INT64_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            VALUES(N)))
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_FLOAT_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = BSWAP_FLOAT(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            VALUES(N)))
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_DOUBLE_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = BSWAP_DOUBLE(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            VALUES(N)))
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_BYTES_VECTOR(SELF, BYTES_ARRAY, ARRAY_LENGTHS, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(OUT) :: BYTES_ARRAY
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), INTENT(OUT) :: ARRAY_LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, LENGTH
      SUCCESS = XDR_GET_BYTES(SELF, BYTES_ARRAY(N), ARRAY_LENGTHS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_STRING_VECTOR(SELF, STRING_ARRAY, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(OUT) :: STRING_ARRAY
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, LENGTH
      SUCCESS = XDR_GET_STRING(SELF, STRING_ARRAY(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_CHARACTER_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = CHAR(BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            X)))
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT8_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = INT(UPCAST_UINT32_T(BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            X))), KIND = C_INT16_T)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT16_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = INT(UPCAST_UINT32_T(BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            VALUES(1)))), KIND = C_INT32_T)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT32_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        VALUES(N) = UPCAST_UINT32_T(BSWAP_INT32_T(TRANSFER(SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T ), &
            X)))
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_LOGICAL_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_LOGICAL_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT8_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_INT8_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT16_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_INT16_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT32_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_INT32_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT64_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_INT64_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_FLOAT_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_FLOAT_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_DOUBLE_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_DOUBLE_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_BYTES_ARRAY(SELF, BYTES_ARRAY, ARRAY_LENGTHS, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(INOUT) :: BYTES_ARRAY
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), INTENT(OUT) :: ARRAY_LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(BYTES_ARRAY)) THEN
      SUCCESS = XDR_GET_BYTES_VECTOR(SELF, BYTES_ARRAY, ARRAY_LENGTHS, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_STRING_ARRAY(SELF, STRING_ARRAY, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(OUT) :: STRING_ARRAY
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(STRING_ARRAY)) THEN
      SUCCESS = XDR_GET_STRING_VECTOR(SELF, STRING_ARRAY, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_CHARACTER_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_CHARACTER_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT8_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_UINT8_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT16_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_UINT16_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT32_ARRAY(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= SIZE(VALUES)) THEN
      SUCCESS = XDR_GET_UINT32_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
      SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_STRING(SELF, STR) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = :), ALLOCATABLE, INTENT(OUT) :: STR
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: LENGTH

    SUCCESS = XDR_GET_INT32(SELF, LENGTH)
    IF (SUCCESS) THEN
      N = MIN(LENGTH, SELF%MAX_STRING_SIZE)
      ALLOCATE(CHARACTER(KIND = C_CHAR, LEN = N) :: STR)
      E = SELF%OFFSET + N - 1
      STR = SELF%BUFFER(SELF%OFFSET:E)
      SELF%OFFSET = SELF%OFFSET + XDR_BLOCK_SIZE(INT(LENGTH, KIND = C_SIZE_T))
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_LOGICAL_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(LOGICAL :: VALUES(LENGTH))
      SUCCESS = XDR_GET_LOGICAL_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_INT8_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(INTEGER(KIND = C_INT8_T) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_INT8_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_INT16_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(INTEGER(KIND = C_INT16_T) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_INT16_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_INT32_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(INTEGER(KIND = C_INT32_T) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_INT32_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_INT64_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(INTEGER(KIND = C_INT64_T) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_INT64_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_FLOAT_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(REAL(KIND = C_FLOAT) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_FLOAT_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_DOUBLE_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(REAL(KIND = C_DOUBLE) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_DOUBLE_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_BYTES_ARRAY(SELF, BYTES_ARRAY, ARRAY_LENGTHS, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: BYTES_ARRAY
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: ARRAY_LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      CALL XDR_ALLOCATE_STRINGS(BYTES_ARRAY, LENGTH, LEN(BYTES_ARRAY(1)))
      ALLOCATE(INTEGER(KIND = C_SIZE_T) :: ARRAY_LENGTHS(LENGTH))
      SUCCESS = XDR_GET_BYTES_VECTOR(SELF, BYTES_ARRAY, ARRAY_LENGTHS, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_STRING_ARRAY(SELF, STRING_ARRAY, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: STRING_ARRAY
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      CALL XDR_ALLOCATE_STRINGS(STRING_ARRAY, LENGTH, LEN(STRING_ARRAY(1)))
      SUCCESS = XDR_GET_STRING_VECTOR(SELF, STRING_ARRAY, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_CHARACTER_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(CHARACTER(KIND = C_CHAR) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_CHARACTER_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_UINT8_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(INTEGER(KIND = C_INT16_T) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_UINT8_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_UINT16_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(INTEGER(KIND = C_INT32_T) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_UINT16_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_ALLOC_UINT32_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    SUCCESS = XDR_GET_INT32(SELF, H)
    LENGTH = INT(H, KIND = C_SIZE_T)
    IF (SUCCESS .AND. LENGTH <= MAXLENGTH) THEN
      ALLOCATE(INTEGER(KIND = C_INT64_T) :: VALUES(LENGTH))
      SUCCESS = XDR_GET_UINT32_VECTOR(SELF, VALUES, LENGTH)
    ELSE IF (SUCCESS) THEN
        SELF%OFFSET = SELF%OFFSET - HEADER_SIZE
        SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_VOID(SELF) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL :: SUCCESS

    SUCCESS = .TRUE.
  END FUNCTION

  FUNCTION XDR_PUT_LOGICAL(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    IF (VAL) THEN
      SUCCESS = XDR_PUT_INT32(SELF, 1_C_INT32_T)
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, 0_C_INT32_T)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = INT(VAL, KIND = C_INT32_T)
    SUCCESS = XDR_PUT_INT32(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_INT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = INT(VAL, KIND = C_INT32_T)
    SUCCESS = XDR_PUT_INT32(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_INT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT32_T(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT64(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT64_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT64_T(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_FLOAT(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    REAL(KIND = C_FLOAT) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_FLOAT(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_DOUBLE(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    REAL(KIND = C_DOUBLE) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_DOUBLE(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_BYTES(SELF, STR, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: STR
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_SIZE_T) :: P
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(SWAPPED) + XDR_BLOCK_SIZE(SIZE) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
      SWAPPED = INT(SIZE, KIND = C_INT32_T)
      SWAPPED = BSWAP_INT32_T(SWAPPED)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1

      E = SELF%OFFSET + SIZE - 1
      SELF%BUFFER(SELF%OFFSET:E) = STR(1:SIZE)
      SELF%OFFSET = E + 1

      P = XDR_BLOCK_SIZE(SIZE) - SIZE
      E = SELF%OFFSET + P - 1
      SELF%BUFFER(SELF%OFFSET:E) = PADDING(1:P)
      SELF%OFFSET = E + 1

      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_STRING(SELF, STR) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: STR
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_SIZE_T) :: P
    INTEGER(KIND = C_SIZE_T) :: SIZE
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    SIZE = LEN(STR)
    E = SELF%OFFSET + C_SIZEOF(SWAPPED) + XDR_BLOCK_SIZE(SIZE) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
      SWAPPED = INT(SIZE, KIND = C_INT32_T)
      SWAPPED = BSWAP_INT32_T(SWAPPED)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1

      E = SELF%OFFSET + SIZE - 1
      SELF%BUFFER(SELF%OFFSET:E) = STR(1:SIZE)
      SELF%OFFSET = E + 1

      P = XDR_BLOCK_SIZE(SIZE) - SIZE
      E = SELF%OFFSET + P - 1
      SELF%BUFFER(SELF%OFFSET:E) = PADDING(1:P)
      SELF%OFFSET = E + 1

      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_CHARACTER(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = ICHAR(VAL)
    SUCCESS = XDR_PUT_INT32(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_UINT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = INT(VAL, KIND = C_INT32_T)
    SUCCESS = XDR_PUT_UINT16(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_UINT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT32_T(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
    IF (E > SELF%BUFFER_SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT32_T(DOWNCAST_UINT32_T(VAL))
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_LOGICAL_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        IF (VALUES(N)) THEN
          X = 1
        ELSE
          X = 0
        END IF
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(X), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT8_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(INT(VALUES(N), KIND = C_INT32_T)), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT16_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(INT(VALUES(N), KIND = C_INT32_T)), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT32_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(VALUES(N)), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT64_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT64_T(VALUES(N)), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_FLOAT_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_FLOAT(VALUES(N)), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_DOUBLE_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_DOUBLE(VALUES(N)), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_BYTES_VECTOR(SELF, STRS, LENGTHS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), INTENT(IN) :: LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_BYTES(SELF, STRS(N), LENGTHS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_STRING_VECTOR(SELF, STRS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_STRING(SELF, STRS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_CHARACTER_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(ICHAR(VALUES(N))), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT8_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(DOWNCAST_UINT32_T( &
            INT(VALUES(N), KIND = C_INT64_T))), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT16_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(DOWNCAST_UINT32_T( &
            INT(VALUES(N), KIND = C_INT64_T))), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT32_VECTOR(SELF, VALUES, LENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: LENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_INT32_T) :: X
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    ELEMENT_SIZE = C_SIZEOF(X)
    IF (SELF%OFFSET + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      DO N = 1, LENGTH
        BUFFER => SELF%BUFFER( &
            SELF%OFFSET + N * ELEMENT_SIZE - ELEMENT_SIZE : &
            SELF%OFFSET + N * ELEMENT_SIZE - 1_C_SIZE_T )
        BUFFER = TRANSFER(BSWAP_INT32_T(DOWNCAST_UINT32_T(VALUES(N))), BUFFER)
      END DO
      SELF%OFFSET = SELF%OFFSET + LENGTH * ELEMENT_SIZE
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_LOGICAL_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_LOGICAL_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT8_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_INT8_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT16_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_INT16_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT32_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_INT32_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT64_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_INT64_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_FLOAT_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_FLOAT_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_DOUBLE_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_DOUBLE_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_CHARACTER_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(VALUES(1))
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_CHARACTER_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT8_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(H)
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_UINT8_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT16_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(H)
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_UINT16_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT32_ARRAY(SELF, VALUES, MAXLENGTH) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALUES
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXLENGTH
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: H
    INTEGER(KIND = C_SIZE_T) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: HEADER_SIZE
    INTEGER(KIND = C_SIZE_T) :: ELEMENT_SIZE

    HEADER_SIZE = C_SIZEOF(H)
    ELEMENT_SIZE = C_SIZEOF(H)
    LENGTH = MIN(SIZE(VALUES, KIND = C_SIZE_T), MAXLENGTH)
    IF (SELF%OFFSET + HEADER_SIZE + LENGTH * ELEMENT_SIZE > SELF%BUFFER_SIZE + 1_C_SIZE_T) THEN
      SUCCESS = .FALSE.
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T)) .AND. &
                XDR_PUT_UINT32_VECTOR(SELF, VALUES, LENGTH)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_BYTES_ARRAY(SELF, STRS, LENGTHS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), INTENT(IN) :: LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(STRS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_BYTES(SELF, STRS(N), LENGTHS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_STRING_ARRAY(SELF, STRS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(STRS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_STRING(SELF, STRS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

END MODULE
